import google.generativeai as genai
import re
from collections import Counter

def generate_keywords_with_weightage(question, model_answer, marks):
    # Configure Gemini API
    genai.configure(api_key="AIzaSyAN6hW728nRG6ITJWMSJYQzSrkaEDeseOk")
    model = genai.GenerativeModel('gemini-pro')

    # Generate AI-based answer
    response = model.generate_content(question)
    ai_generated_answer = response.text.strip() if response.text else ""

    # Create a more specific prompt for keyword extraction with weightage
    prompt = f"""

    Analyze this question and its answers to provide keywords with their importance weightage (0.1-100):
    
    Question: {question}
    Model Answer: {model_answer}
    AI Generated Answer: {ai_generated_answer}
    Marks: {marks}

    For lower marks question(1 marks), consider the answer has one main keyword and rank that keyword with highest weightage
    Rules for keyword weightage:
    2. Core concept keywords should have higher weightage
    3. Supporting concept keywords should have medium weightage
    4. Additional detail keywords should have lower weightage
    5. If the question asks for full form of something then that full form will be the highest weightage keyword
    6. If the keyword generated by the model is already present in the question do not consider that keyword
    
    Provide output in this exact format (one per line):
    keyword1: weightage
    keyword2: weightage
    keyword3: weightage
    """

    # Get keyword suggestions from Gemini
    response = model.generate_content(prompt)
    keywords_text = response.text.strip()

    # Parse the response into a dictionary
    keyword_weights = {}
    for line in keywords_text.split('\n'):
        if ':' in line:
            keyword, weight = line.split(':')
            keyword = keyword.strip().lower()
            try:
                weight = float(weight.strip())
                # Ensure weight is within valid range
                weight = max(1, min(100, weight))
                keyword_weights[keyword] = weight
            except ValueError:
                continue

    # If we got no valid keywords, create a fallback analysis
    if not keyword_weights:
        # Combine all answers and extract key terms
        combined_text = f"{question} {model_answer} {ai_generated_answer}"
        words = re.findall(r'\b\w+\b', combined_text.lower())
        word_freq = Counter(words)
        
        # Filter out common words and create basic weightage
        common_words = {'is', 'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for'}
        keywords = {word: count for word, count in word_freq.items() 
                   if word not in common_words and len(word) > 2}
        
        if keywords:
            max_freq = max(keywords.values())
            base_weight = 100 if marks <= 2 else 70  # Higher base weight for lower marks
            
            for word, freq in keywords.items():
                weight = (freq / max_freq) * base_weight
                keyword_weights[word] = round(max(1, min(100, weight)), 2)

    # Sort keywords by weight
    keyword_weights = dict(sorted(keyword_weights.items(), 
                                key=lambda x: x[1], 
                                reverse=True))

    # Limit number of keywords based on marks
    max_keywords = min(marks * 3, 10)  # Scale with marks but cap at 10
    keyword_weights = dict(list(keyword_weights.items())[:max_keywords])

    return keyword_weights

def main():
    print("\nKeyword Generator for Answer Checking")
    print("====================================")
    
    # Get inputs with better prompting
    question = input("\nEnter the question: ")
    print("\nEnter the model answer (press Enter twice to finish):")
    
    # Collect multiline input for model answer
    model_answer_lines = []
    while True:
        line = input()
        if line == "":
            break
        model_answer_lines.append(line)
    model_answer = " ".join(model_answer_lines)
    
    while True:
        try:
            marks = int(input("\nEnter the marks for the question (1-20): "))
            if 1 <= marks <= 20:
                break
            print("Please enter marks between 1 and 20")
        except ValueError:
            print("Please enter a valid number")

    print("\nGenerating keywords and weightages...")
    keywords_with_weights = generate_keywords_with_weightage(question, model_answer, marks)

    # Print results in a formatted way
    print("\nGenerated Keywords with Weightages:")
    print("-" * 40)
    max_keyword_length = max(len(keyword) for keyword in keywords_with_weights.keys())
    for keyword, weight in keywords_with_weights.items():
        print(f"{keyword:<{max_keyword_length}} : {weight:>6.2f}%")

if __name__ == "__main__":
    main()